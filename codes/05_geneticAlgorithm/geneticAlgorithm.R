# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------

fitnessFunction = function(problem, individual) {
	ids0 = which(individual == 0)
	fit = abs(sum(problem[ids0]) - sum(problem[-ids0]))
	return(fit)
}

# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------

tournamentSelection = function(population, fitness.values, k=3) {
	challengers = sample(x= 1:nrow(population), size = k)
	id.min = which.min(fitness.values[challengers])
	best = population[challengers[id.min],]
	return(best)
}

# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------

onePointCrossover = function(parentA, parentB) {
	CUTOFF = sample(x =(2:(N-1)), size = 1)
	child1 = c(parentA[1:CUTOFF], parentB[(CUTOFF+1):N])
	child2 = c(parentB[1:CUTOFF], parentA[(CUTOFF+1):N])
	children = list(child1 = child1, child2 = child2)
	return(children)
}

# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------

uniformMutation = function(children, mut.prob = 0.001) {

	for(i in 1:length(children$child1)) {
		prob = sample(x = 1:100, size = 1)
		if(prob <= (mut.prob*100)) {
			children$child1[i] = 1 - children$child1[i] 
		}
	}
	for(i in 1:length(children$child2)) {
		prob = sample(x = 1:100, size = 1)
		if(prob <= (mut.prob*100)) {
			children$child2[i] = 1 - children$child2[i] 
		}
	}
	return(children)
}

# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------

geneticAlgorithm = function(problem, pop.size = POP.SIZE, generations = GERACOES) {

	# --------------------------------
	# some variables to return
	bests = c()						# best solutions so far (per generation)
	average.fitness = c()			# average fitness (per generation)
	all.populations = list()		# all populations generated by the GA
	all.fitness     = list()		# all fitness values evaluated
	# --------------------------------

	# 1. Generate a random population (P)
	population = matrix(0, nrow = POP.SIZE, ncol = N)
	fitness.values = array(0, dim = POP.SIZE)
	
	# 2. Evaluate population fitness
	for(i in 1:POP.SIZE) {
		population[i,] = sample(x = c(0,1), size = N, replace = TRUE)
		fitness.values[i] = fitnessFunction(problem = problem, individual = population[i,])
	}

	#-------------------------------------------------------
	# adding first population details to the return object
	#-------------------------------------------------------
	all.populations[[1]] = population
	all.fitness[[1]] = fitness.values
	bests = c(bests, min(fitness.values))
	average.fitness = c(average.fitness, mean(fitness.values))
	#-------------------------------------------------------

	
	# 3. Repeat
	for(k in 1:generations) {
		cat(" - Geração: ", k)
	# 	 4. Generate new population (Q)
		new.population = matrix(0, nrow = POP.SIZE, ncol = N)
		for(j in 1:(POP.SIZE/2)) {
	# 		a) Select parents
			parentA = tournamentSelection(population, fitness.values, k=3)
			parentB = tournamentSelection(population, fitness.values, k=3)

	#		b) crossover
			children = onePointCrossover(parentA, parentB)

	#       c) mutation 
			xmen = uniformMutation(children, mut.prob = 0.01)
			idx1 = (2*j)-1
			idx2 = 2*j
			new.population[idx1, ] = xmen$child1
			new.population[idx2, ] = xmen$child2
		}

	# 	 5. Replace population P with Q
		population = new.population
	# 	 6. Evaluate new population fitness
		for(i in 1:POP.SIZE) {
			fitness.values[i] = fitnessFunction(problem = problem, individual = population[i,])
		}

		#-------------------------------------------------------
		# adding population details' to the return object
		#-------------------------------------------------------
		all.populations[[k+1]] = population
		all.fitness[[k+1]] = fitness.values
		bests = c(bests, min(fitness.values))
		average.fitness = c(average.fitness, mean(fitness.values))
		cat(" @ best fitness: ", min(fitness.values), " @avg fitness: ", mean(fitness.values), "\n")
	}

	# --------------------------------
	# retornar (melhor(es) individuos, populacao final)
	obj = list(bests = bests, average.fitness = average.fitness, 
		all.populations = all.populations, all.fitness = all.fitness)
	return (obj)
	# --------------------------------
	
}

# -------------------------------------------------------
# -------------------------------------------------------
